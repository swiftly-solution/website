---
title: SteamGameServerNetworking
---

# Class SteamGameServerNetworking

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L5" />

**Namespace**: [SwiftlyS2.Shared.SteamAPI](/docs/api/steamapi)

**Assembly**: SwiftlyS2.CS2.dll

```csharp
public static class SteamGameServerNetworking
```

#### Inheritance

- [object](https://learn.microsoft.com/dotnet/api/system.object)
- [SteamGameServerNetworking](/docs/api/steamapi/steamgameservernetworking)

#### Inherited Members

- [object.Equals(object?)](https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object))
- [object.Equals(object?, object?)](https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object))
- [object.GetHashCode()](https://learn.microsoft.com/dotnet/api/system.object.gethashcode)
- [object.GetType()](https://learn.microsoft.com/dotnet/api/system.object.gettype)
- [object.MemberwiseClone()](https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone)
- [object.ReferenceEquals(object?, object?)](https://learn.microsoft.com/dotnet/api/system.object.referenceequals)
- [object.ToString()](https://learn.microsoft.com/dotnet/api/system.object.tostring)

## Methods

### AcceptP2PSessionWithUser(CSteamID)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L56" />

<p> AcceptP2PSessionWithUser() should only be called in response to a P2PSessionRequest_t callback</p>
<p> P2PSessionRequest_t will be posted if another user tries to send you a packet that you haven't talked to yet</p>
<p> if you don't want to talk to the user, just ignore the request</p>
<p> if the user continues to send you packets, another P2PSessionRequest_t will be posted periodically</p>
<p> this may be called multiple times for a single user</p>
<p> (if you've called SendP2PPacket() on the other user, this implicitly accepts the session request)</p>

```csharp
public static bool AcceptP2PSessionWithUser(CSteamID steamIDRemote)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### AllowP2PPacketRelay(bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L99" />

<p> Allow P2P connections to fall back to being relayed through the Steam servers if a direct connection</p>
<p> or NAT-traversal cannot be established. Only applies to connections created after setting this value,</p>
<p> or to existing connections that need to automatically reconnect after this value is set.</p>
<p> P2P packet relay is allowed by default</p>
<p> NOTE: This function is deprecated and may be removed in a future version of the SDK.  For</p>
<p> security purposes, we may decide to relay the traffic to certain peers, even if you pass false</p>
<p> to this function, to prevent revealing the client's IP address top another peer.</p>

```csharp
public static bool AllowP2PPacketRelay(bool bAllow)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="bAllow" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### CloseP2PChannelWithUser(CSteamID, int)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L75" />

<p> call CloseP2PChannelWithUser() when you're done talking to a user on a specific channel. Once all channels</p>
<p> open channels to a user have been closed, the open session to the user will be closed and new data from this</p>
<p> user will trigger a P2PSessionRequest_t callback</p>

```csharp
public static bool CloseP2PChannelWithUser(CSteamID steamIDRemote, int nChannel)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="nChannel" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### CloseP2PSessionWithUser(CSteamID)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L65" />

<p> call CloseP2PSessionWithUser() when you're done talking to a user, will free up resources under-the-hood</p>
<p> if the remote user tries to send data to you again, another P2PSessionRequest_t callback will be posted</p>

```csharp
public static bool CloseP2PSessionWithUser(CSteamID steamIDRemote)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### CreateConnectionSocket(SteamIPAddress_t, ushort, int)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L142" />

```csharp
public static SNetSocket_t CreateConnectionSocket(SteamIPAddress_t nIP, ushort nPort, int nTimeoutSec)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="nIP" type="SteamIPAddress_t" typeHref="/docs/api/steamapi/steamipaddress_t" />
- <ApiParam name="nPort" type="ushort" typeHref="https://learn.microsoft.com/dotnet/api/system.uint16" />
- <ApiParam name="nTimeoutSec" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

### CreateListenSocket(int, SteamIPAddress_t, ushort, bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L126" />

<p>//////////////////////////////////////////////////////////////////////////////////////////</p>
<p> LISTEN / CONNECT connection-oriented interface functions</p>
<p> These functions are more like a client-server TCP API.  One side is the "server"</p>
<p> and "listens" for incoming connections, which then must be "accepted."  The "client"</p>
<p> initiates a connection by "connecting."  Sending and receiving is done through a</p>
<p> connection handle.</p>
<p> For a more UDP-style interface, where you do not track connection handles but</p>
<p> simply send messages to a SteamID, use the UDP-style functions above.</p>
<p> Both methods can send both reliable and unreliable methods.</p>
<p> These APIs are deprecated, and may be removed in a future version of the Steamworks</p>
<p> SDK.  See ISteamNetworkingSockets.</p>
<p>//////////////////////////////////////////////////////////////////////////////////////////</p>
<p> creates a socket and listens others to connect</p>
<p> will trigger a SocketStatusCallback_t callback on another client connecting</p>
<p> nVirtualP2PPort is the unique ID that the client will connect to, in case you have multiple ports</p>
<p>		this can usually just be 0 unless you want multiple sets of connections</p>
<p> unIP is the local IP address to bind to</p>
<p>		pass in 0 if you just want the default local IP</p>
<p> unPort is the port to use</p>
<p>		pass in 0 if you don't want users to be able to connect via IP/Port, but expect to be always peer-to-peer connections only</p>

```csharp
public static SNetListenSocket_t CreateListenSocket(int nVirtualP2PPort, SteamIPAddress_t nIP, ushort nPort, bool bAllowUseOfPacketRelay)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="nVirtualP2PPort" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />
- <ApiParam name="nIP" type="SteamIPAddress_t" typeHref="/docs/api/steamapi/steamipaddress_t" />
- <ApiParam name="nPort" type="ushort" typeHref="https://learn.microsoft.com/dotnet/api/system.uint16" />
- <ApiParam name="bAllowUseOfPacketRelay" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="SNetListenSocket_t" typeHref="/docs/api/steamapi/snetlistensocket_t" />

### CreateP2PConnectionSocket(CSteamID, int, int, bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L137" />

<p> creates a socket and begin connection to a remote destination</p>
<p> can connect via a known steamID (client or game server), or directly to an IP</p>
<p> on success will trigger a SocketStatusCallback_t callback</p>
<p> on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in m_eSNetSocketState</p>

```csharp
public static SNetSocket_t CreateP2PConnectionSocket(CSteamID steamIDTarget, int nVirtualPort, int nTimeoutSec, bool bAllowUseOfPacketRelay)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDTarget" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="nVirtualPort" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />
- <ApiParam name="nTimeoutSec" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />
- <ApiParam name="bAllowUseOfPacketRelay" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

### DestroyListenSocket(SNetListenSocket_t, bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L160" />

<p> destroying a listen socket will automatically kill all the regular sockets generated from it</p>

```csharp
public static bool DestroyListenSocket(SNetListenSocket_t hSocket, bool bNotifyRemoteEnd)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetListenSocket_t" typeHref="/docs/api/steamapi/snetlistensocket_t" />
- <ApiParam name="bNotifyRemoteEnd" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### DestroySocket(SNetSocket_t, bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L152" />

<p> disconnects the connection to the socket, if any, and invalidates the handle</p>
<p> any unread data on the socket will be thrown away</p>
<p> if bNotifyRemoteEnd is set, socket will not be completely destroyed until the remote end acknowledges the disconnect</p>

```csharp
public static bool DestroySocket(SNetSocket_t hSocket, bool bNotifyRemoteEnd)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />
- <ApiParam name="bNotifyRemoteEnd" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### GetListenSocketInfo(SNetListenSocket_t, out SteamIPAddress_t, out ushort)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L234" />

<p> returns which local port the listen socket is bound to</p>
<p> *pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only</p>

```csharp
public static bool GetListenSocketInfo(SNetListenSocket_t hListenSocket, out SteamIPAddress_t pnIP, out ushort pnPort)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hListenSocket" type="SNetListenSocket_t" typeHref="/docs/api/steamapi/snetlistensocket_t" />
- <ApiParam name="pnIP" type="SteamIPAddress_t" typeHref="/docs/api/steamapi/steamipaddress_t" />
- <ApiParam name="pnPort" type="ushort" typeHref="https://learn.microsoft.com/dotnet/api/system.uint16" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### GetMaxPacketSize(SNetSocket_t)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L250" />

<p> max packet size, in bytes</p>

```csharp
public static int GetMaxPacketSize(SNetSocket_t hSocket)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

### GetP2PSessionState(CSteamID, out P2PSessionState_t)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L85" />

<p> fills out P2PSessionState_t structure with details about the underlying connection to the user</p>
<p> should only needed for debugging purposes</p>
<p> returns false if no connection exists to the specified user</p>

```csharp
public static bool GetP2PSessionState(CSteamID steamIDRemote, out P2PSessionState_t pConnectionState)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="pConnectionState" type="P2PSessionState_t" typeHref="/docs/api/steamapi/p2psessionstate_t" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### GetSocketConnectionType(SNetSocket_t)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L242" />

<p> returns true to describe how the socket ended up connecting</p>

```csharp
public static ESNetSocketConnectionType GetSocketConnectionType(SNetSocket_t hSocket)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="ESNetSocketConnectionType" typeHref="/docs/api/steamapi/esnetsocketconnectiontype" />

### GetSocketInfo(SNetSocket_t, out CSteamID, out int, out SteamIPAddress_t, out ushort)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L225" />

<p> returns information about the specified socket, filling out the contents of the pointers</p>

```csharp
public static bool GetSocketInfo(SNetSocket_t hSocket, out CSteamID pSteamIDRemote, out int peSocketStatus, out SteamIPAddress_t punIPRemote, out ushort punPortRemote)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />
- <ApiParam name="pSteamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="peSocketStatus" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />
- <ApiParam name="punIPRemote" type="SteamIPAddress_t" typeHref="/docs/api/steamapi/steamipaddress_t" />
- <ApiParam name="punPortRemote" type="ushort" typeHref="https://learn.microsoft.com/dotnet/api/system.uint16" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### IsDataAvailable(SNetListenSocket_t, out uint, out SNetSocket_t)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L204" />

<p> checks for data from any socket that has been connected off this listen socket</p>
<p> returns false if there is no data remaining</p>
<p> fills out *pcubMsgSize with the size of the next message, in bytes</p>
<p> fills out *phSocket with the socket that data is available on</p>

```csharp
public static bool IsDataAvailable(SNetListenSocket_t hListenSocket, out uint pcubMsgSize, out SNetSocket_t phSocket)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hListenSocket" type="SNetListenSocket_t" typeHref="/docs/api/steamapi/snetlistensocket_t" />
- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="phSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### IsDataAvailableOnSocket(SNetSocket_t, out uint)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L182" />

<p> receiving data</p>
<p> returns false if there is no data remaining</p>
<p> fills out *pcubMsgSize with the size of the next message, in bytes</p>

```csharp
public static bool IsDataAvailableOnSocket(SNetSocket_t hSocket, out uint pcubMsgSize)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />
- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### IsP2PPacketAvailable(out uint, int)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L32" />

<p> returns true if any data is available for read, and the amount of data that will need to be read</p>

```csharp
public static bool IsP2PPacketAvailable(out uint pcubMsgSize, int nChannel = 0)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="nChannel" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### ReadP2PPacket(byte[], uint, out uint, out CSteamID, int)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L43" />

<p> reads in a packet that has been sent from another user via SendP2PPacket()</p>
<p> returns the size of the message and the steamID of the user who sent it in the last two parameters</p>
<p> if the buffer passed in is too small, the message will be truncated</p>
<p> this call is not blocking, and will return false if no data is available</p>

```csharp
public static bool ReadP2PPacket(byte[] pubDest, uint cubDest, out uint pcubMsgSize, out CSteamID psteamIDRemote, int nChannel = 0)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="pubDest" type="byte[]" typeHref="https://learn.microsoft.com/dotnet/api/system.byte" />
- <ApiParam name="cubDest" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="psteamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="nChannel" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### RetrieveData(SNetListenSocket_t, byte[], uint, out uint, out SNetSocket_t)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L217" />

<p> retrieves data from any socket that has been connected off this listen socket</p>
<p> fills in pubDest with the contents of the message</p>
<p> messages are always complete, of the same size as was sent (i.e. packetized, not streaming)</p>
<p> if *pcubMsgSize &lt; cubDest, only partial data is written</p>
<p> returns false if no data is available</p>
<p> fills out *phSocket with the socket that data is available on</p>

```csharp
public static bool RetrieveData(SNetListenSocket_t hListenSocket, byte[] pubDest, uint cubDest, out uint pcubMsgSize, out SNetSocket_t phSocket)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hListenSocket" type="SNetListenSocket_t" typeHref="/docs/api/steamapi/snetlistensocket_t" />
- <ApiParam name="pubDest" type="byte[]" typeHref="https://learn.microsoft.com/dotnet/api/system.byte" />
- <ApiParam name="cubDest" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="phSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### RetrieveDataFromSocket(SNetSocket_t, byte[], uint, out uint)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L193" />

<p> fills in pubDest with the contents of the message</p>
<p> messages are always complete, of the same size as was sent (i.e. packetized, not streaming)</p>
<p> if *pcubMsgSize &lt; cubDest, only partial data is written</p>
<p> returns false if no data is available</p>

```csharp
public static bool RetrieveDataFromSocket(SNetSocket_t hSocket, byte[] pubDest, uint cubDest, out uint pcubMsgSize)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />
- <ApiParam name="pubDest" type="byte[]" typeHref="https://learn.microsoft.com/dotnet/api/system.byte" />
- <ApiParam name="cubDest" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="pcubMsgSize" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### SendDataOnSocket(SNetSocket_t, byte[], uint, bool)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L172" />

<p> sending data</p>
<p> must be a handle to a connected socket</p>
<p> data is all sent via UDP, and thus send sizes are limited to 1200 bytes; after this, many routers will start dropping packets</p>
<p> use the reliable flag with caution; although the resend rate is pretty aggressive,</p>
<p> it can still cause stalls in receiving data (like TCP)</p>

```csharp
public static bool SendDataOnSocket(SNetSocket_t hSocket, byte[] pubData, uint cubData, bool bReliable)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="hSocket" type="SNetSocket_t" typeHref="/docs/api/steamapi/snetsocket_t" />
- <ApiParam name="pubData" type="byte[]" typeHref="https://learn.microsoft.com/dotnet/api/system.byte" />
- <ApiParam name="cubData" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="bReliable" type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

### SendP2PPacket(CSteamID, byte[], uint, EP2PSend, int)

<ViewSource href="https://github.com/swiftly-solution/swiftlys2/blob/master/managed/src/SwiftlyS2.Generated/SteamAPI/isteamgameservernetworking.cs#L24" />

<p>//////////////////////////////////////////////////////////////////////////////////////////</p>
<p> UDP-style (connectionless) networking interface.  These functions send messages using</p>
<p> an API organized around the destination.  Reliable and unreliable messages are supported.</p>
<p> For a more TCP-style interface (meaning you have a connection handle), see the functions below.</p>
<p> Both interface styles can send both reliable and unreliable messages.</p>
<p> Automatically establishes NAT-traversing or Relay server connections</p>
<p> These APIs are deprecated, and may be removed in a future version of the Steamworks</p>
<p> SDK.  See ISteamNetworkingMessages.</p>
<p> Sends a P2P packet to the specified user</p>
<p> UDP-like, unreliable and a max packet size of 1200 bytes</p>
<p> the first packet send may be delayed as the NAT-traversal code runs</p>
<p> if we can't get through to the user, an error will be posted via the callback P2PSessionConnectFail_t</p>
<p> see EP2PSend enum above for the descriptions of the different ways of sending packets</p>
<p> nChannel is a routing number you can use to help route message to different systems 	- you'll have to call ReadP2PPacket()</p>
<p> with the same channel number in order to retrieve the data on the other end</p>
<p> using different channels to talk to the same user will still use the same underlying p2p connection, saving on resources</p>

```csharp
public static bool SendP2PPacket(CSteamID steamIDRemote, byte[] pubData, uint cubData, EP2PSend eP2PSendType, int nChannel = 0)
```

<ApiLabel>Parameters</ApiLabel>

- <ApiParam name="steamIDRemote" type="CSteamID" typeHref="/docs/api/steamapi/csteamid" />
- <ApiParam name="pubData" type="byte[]" typeHref="https://learn.microsoft.com/dotnet/api/system.byte" />
- <ApiParam name="cubData" type="uint" typeHref="https://learn.microsoft.com/dotnet/api/system.uint32" />
- <ApiParam name="eP2PSendType" type="EP2PSend" typeHref="/docs/api/steamapi/ep2psend" />
- <ApiParam name="nChannel" type="int" typeHref="https://learn.microsoft.com/dotnet/api/system.int32" />

<ApiLabel>Returns</ApiLabel>

- <ApiParam type="bool" typeHref="https://learn.microsoft.com/dotnet/api/system.boolean" />

