---
title: Entity
---

Various information about entity and entity system.

## Entity

An entity is a game object, which can be created or removed.

## Create an entity

Example:
```csharp
var entity = Core.EntitySystem.CreateEntity<CPointWorldText>();
```
This example creates a `point_worldtext` entity with class `CPointWorldText`.
You can also use `CreateEntityByDesignerName` to create an entity by specifying the designer name.

## Get existing entities

You can use methods in entity system to get existing entities.

<Callout type="warning">
  The methods that return multiple entities return an `IEnumerable<T>` type.
  It's recommended to use Linq to query entities, to avoid too much iteration.
</Callout>

### Get all entities
Example:
```csharp
var entities = Core.EntitySystem.GetAllEntities();
```

### Get entities by class

Example:

```csharp
var entities = Core.EntitySystem.GetEntityByClass<CPointWorldText>();
```

## Entity Handle

Entity Handle is a handle to a game entity, which is also a unique identifier for an entity.
<Callout type="info">
  It consists of two parts:
  - Entity Index (15 bit)
  - Serial Number (17 bit)

  Combined together, it is a uint32.
</Callout>

### Get entity by handle

```csharp
var entity = handle.Value;
```
The result will be null if the entity is invalid.

### Get handle by entity

```csharp
var handle = Core.EntitySystem.GetRefEHandle(entity);
```

## Entity Safety

In practice, you are very likely to write such codes like this:
```csharp
List<CBaseEntity> entities = new();

// Entity from various sources
var entity = Core.EntitySystem.CreateEntity<CBaseEntity>();
entities.Add(entity);

// You delete it somewhere
entity.Despawn();

Core.Scheduler.DelayBySeconds(10f, () => {
  foreach (var entity in entities) {
    // Use deleted entity here
  }
});
```

Unfortunately, this is a **TERRIBLY BAD** practice, because you can't ensure the validity of entity and will get a crash if it's invalid.
In fact, there's not way to safely know whether an entity object is valid or not without costing performance.
The best practice is to use `CHandle<T>` as an container to wrap all entity that you want to keep track of for a long time.
Example:

```csharp
List<CHandle<CBaseEntity>> entities = new();

// Entity from various sources
// At this point entity is ensured to be valid, so we can safely get its EntityHandle
var entity = Core.EntitySystem.CreateEntity<CBaseEntity>();
entities.Add(Core.EntitySystem.GetRefEHandle(entity));

// The entity is deleted somewhere
entity.Despawn();

Core.Scheduler.DelayBySeconds(10f, () => {
  foreach (var handle in entities) {
    // Use deleted entity here
    // This will throws an exception because the entity is invalid
    var entity = handle.Value;

    // And you can also check the validity of the handle.
    var isValid = handle.IsValid;
  }
});
```


## Entity system

See also [IEntitySystemService](/docs/api/entitysystem/ientitysystemservice/)